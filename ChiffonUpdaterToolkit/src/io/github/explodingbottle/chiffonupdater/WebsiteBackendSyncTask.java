/*
 * This file is part of ChiffonUpdater
 *
 * SPDX-License-Identifier: MIT
 */

package io.github.explodingbottle.chiffonupdater;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStreamWriter;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.StandardCopyOption;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.zip.Deflater;
import java.util.zip.GZIPInputStream;
import java.util.zip.GZIPOutputStream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

import io.github.explodingbottle.chiffonupdater.binpack.Binpack;
import io.github.explodingbottle.chiffonupdater.binpack.BinpackProvider;
import io.github.explodingbottle.chiffonupdater.project.CustomizationInfos;
import io.github.explodingbottle.chiffonupdater.project.ProductInfo;
import io.github.explodingbottle.chiffonupdater.project.VersionInfo;
import io.github.explodingbottle.chiffonupdater.tasks.ToolkitTask;

public class WebsiteBackendSyncTask extends ToolkitTask {

	private ToolkitWindow toolkitWindow;
	private GlobalLogger logger;
	private ChiffonUpdaterProject project;
	private Map<ProductInfo, File> productSources;
	private boolean regenerateCatalog;

	private static final String PROP_FILE_COMMENT = "Generated by Chiffon Updater Toolkit";

	private void cleanupFolderCatalogProc(File catalogFolder, File poolFolder) {
		for (File f : catalogFolder.listFiles()) {
			if (!f.equals(poolFolder)) {
				if (!f.delete()) {
					logger.print("Couldn't clean up file " + f.getName() + " in the catalog folder.");
				}
			}
		}
		for (File f : poolFolder.listFiles()) {
			if (!f.equals(poolFolder)) {
				if (!f.delete()) {
					logger.print("Couldn't clean up file " + f.getName() + " in the catalog pool folder.");
				}
			}
		}
	}

	public WebsiteBackendSyncTask(ToolkitWindow toolkitWindow, ChiffonUpdaterProject project, GlobalLogger logger,
			Map<ProductInfo, File> productSources, boolean regenerateCatalog) {
		super(toolkitWindow);
		this.toolkitWindow = toolkitWindow;
		this.logger = logger;
		this.project = project;
		this.productSources = productSources;
		this.regenerateCatalog = regenerateCatalog;
		setShouldImpactMainWindow(true);
	}

	public static boolean writeToZipOutputStream(GlobalLogger logger, File input, ZipOutputStream output) {
		byte buf[] = new byte[4096];
		try (FileInputStream fis = new FileInputStream(input)) {
			int read = fis.read(buf, 0, buf.length);
			while (read != -1) {
				output.write(buf, 0, read);
				read = fis.read(buf, 0, buf.length);
			}
		} catch (IOException e) {
			logger.printThrowable(e);
			return false;
		}
		return true;
	}

	@Override
	public void runTask() {
		File connectedBackendFolder = toolkitWindow.getCurrentlyConnectedBackend();
		if (connectedBackendFolder == null) {
			return;
		}
		BinpackProvider prov = new BinpackProvider();
		Binpack binpack = prov.getBinPack(returnWindow());
		if (binpack == null) {
			return;
		}

		logger.print("BackendSync started!");
		// Manifest frontendCompatibleCfg = new Manifest();
		String agentDlUrl = project.getMainInfosRef().getWebsiteInfos().getAgentDlUrl();
		Properties defaultDownloadUrlProps = new Properties();
		try (InputStream stream = BinpackProvider.getDefaultBinpackConfigStream()) {
			defaultDownloadUrlProps.load(stream);
		} catch (IOException e) {
			logger.printThrowable(e);
			return;
		}
		if (agentDlUrl == null || agentDlUrl.isEmpty()) {
			agentDlUrl = defaultDownloadUrlProps.getProperty("agent");
		}
		if (agentDlUrl == null) {
			logger.print("No agent download URL available.");
			return;
		}
		File configFolder = new File(connectedBackendFolder, "config");
		if (!configFolder.exists() && !configFolder.mkdir()) {
			logger.print("Failed to create the config folder.");
			return;
		}
		File webCompatFolder = new File(configFolder, "webcompat");
		if (!webCompatFolder.exists() && !webCompatFolder.mkdir()) {
			logger.print("Failed to create the web compat folder.");
			return;
		}

		File feCompatCfg = new File(webCompatFolder, "agent_dl.html");
		try (BufferedWriter fos = new BufferedWriter(
				new OutputStreamWriter(new FileOutputStream(feCompatCfg), StandardCharsets.UTF_8))) {
			fos.write("<!DOCTYPE html>");
			fos.newLine();
			fos.write("<!-- File automatically generated by ChiffonUpdater Toolkit -->");
			fos.newLine();
			fos.write("<html>");
			fos.newLine();
			fos.write("<head>");
			fos.newLine();
			fos.write("<meta charset=\"utf-8\">");
			fos.newLine();
			fos.write("<title>ChiffonUpdater Agent Download</title>");
			fos.newLine();
			fos.write("<meta http-equiv=\"refresh\" content='0;url=" + agentDlUrl + "'>");
			fos.newLine();
			fos.write("</head>");
			fos.newLine();
			fos.write("</html>");
			fos.newLine();
		} catch (IOException e) {
			logger.printThrowable(e);
			return;
		}
		logger.print("Web-compatible configuration file written.");

		Properties providerProps = project.getMainInfosRef().createPropertiesFromInfos();
		Properties agentProps = new Properties();
		String updaterPackageUrl = project.getMainInfosRef().getWebsiteInfos().getPackageDlUrl();
		String updaterPackageVersUrl = project.getMainInfosRef().getWebsiteInfos().getPackageVersDlUrl();
		if (updaterPackageUrl == null || updaterPackageUrl.isEmpty()) {
			updaterPackageUrl = defaultDownloadUrlProps.getProperty("updater");
		}
		if (updaterPackageVersUrl == null || updaterPackageVersUrl.isEmpty()) {
			updaterPackageVersUrl = defaultDownloadUrlProps.getProperty("package-versions");
		}
		if (updaterPackageVersUrl == null || updaterPackageUrl == null) {
			logger.print("No package URLs available.");
			return;
		}
		agentProps.setProperty("agent.package.dlurl", updaterPackageUrl);
		agentProps.setProperty("agent.package.vrurl", updaterPackageVersUrl);

		CustomizationInfos customInfos = project.getMainInfosRef().getCustomizationInfos();

		String customAgentTitle = customInfos.getCustomAgentTitle();
		if (customAgentTitle != null && !customAgentTitle.trim().isEmpty()) {
			agentProps.setProperty("agent.customization.title", customAgentTitle);
		}
		String customPackageTitle = customInfos.getCustomPackageTitle();
		if (customPackageTitle != null && !customPackageTitle.trim().isEmpty()) {
			agentProps.setProperty("agent.package.customization.title", customPackageTitle);
		}

		File customAgentIconFile = null, customPackageIconFile = null, customPackageBannerFile = null;

		File sourceFolder = toolkitWindow.getCurrentConnectedSource();
		String customAgentIconPath = customInfos.getCustomAgentIconPath();
		if (customAgentIconPath != null && !customAgentIconPath.trim().isEmpty()) {
			customAgentIconFile = new File(customAgentIconPath);
			if (sourceFolder != null) {
				customAgentIconFile = new File(sourceFolder, customAgentIconPath);
			}
			if (!customAgentIconFile.exists()) {
				logger.print("Failed, custom agent icon file couldn't be found.");
				return;
			} else {
				agentProps.setProperty("agent.customization.icon", "agent_cust_icon.png");
			}
		}

		String customPackageIconPath = customInfos.getCustomPackageIconPath();
		if (customPackageIconPath != null && !customPackageIconPath.trim().isEmpty()) {
			customPackageIconFile = new File(customPackageIconPath);
			if (sourceFolder != null) {
				customPackageIconFile = new File(sourceFolder, customPackageIconPath);
			}
			if (!customPackageIconFile.exists()) {
				logger.print("Failed, custom package icon file couldn't be found.");
				return;
			} else {
				agentProps.setProperty("agent.package.customization.icon", "package_cust_icon.png");
			}
		}

		String customPackageBannerPath = customInfos.getCustomPackageBannerPath();
		if (customPackageBannerPath != null && !customPackageBannerPath.trim().isEmpty()) {
			customPackageBannerFile = new File(customPackageBannerPath);
			if (sourceFolder != null) {
				customPackageBannerFile = new File(sourceFolder, customPackageBannerPath);
			}
			if (!customPackageBannerFile.exists()) {
				logger.print("Failed, custom package banner file couldn't be found.");
				return;
			} else {
				agentProps.setProperty("agent.package.customization.banner", "package_cust_banner.png");
			}
		}

		File agentcfgZip = new File(configFolder, "agentcfg1.zip");
		File customizationZip = new File(configFolder, "customization.zip");

		try (ZipOutputStream output = new ZipOutputStream(new FileOutputStream(agentcfgZip))) {
			output.setLevel(Deflater.BEST_COMPRESSION);
			ZipEntry nextEntry = new ZipEntry("provider.properties");
			output.putNextEntry(nextEntry);
			providerProps.store(output, PROP_FILE_COMMENT);
			nextEntry = new ZipEntry("agent.properties");
			output.putNextEntry(nextEntry);
			agentProps.store(output, PROP_FILE_COMMENT);

			output.closeEntry();
		} catch (IOException e) {
			logger.printThrowable(e);
			logger.print("Couldn't write agent config.");
			return;
		}
		if (customAgentIconFile != null || customPackageIconFile != null || customPackageBannerFile != null) {
			try (ZipOutputStream output = new ZipOutputStream(new FileOutputStream(customizationZip))) {
				output.setLevel(Deflater.BEST_COMPRESSION);
				ZipEntry nextEntry;
				if (customAgentIconFile != null) {
					nextEntry = new ZipEntry("agent_cust_icon.png");
					output.putNextEntry(nextEntry);
					if (!writeToZipOutputStream(getLogger(), customAgentIconFile, output)) {
						logger.print("Couldn't load up agent custom icon.");
						return;
					}
				}
				if (customPackageIconFile != null) {
					nextEntry = new ZipEntry("package_cust_icon.png");
					output.putNextEntry(nextEntry);
					if (!writeToZipOutputStream(getLogger(), customPackageIconFile, output)) {
						logger.print("Couldn't load up package custom icon.");
						return;
					}
				}
				if (customPackageBannerFile != null) {
					nextEntry = new ZipEntry("package_cust_banner.png");
					output.putNextEntry(nextEntry);
					if (!writeToZipOutputStream(getLogger(), customPackageBannerFile, output)) {
						logger.print("Couldn't load up package custom banner.");
						return;
					}
				}
				output.closeEntry();
			} catch (IOException e) {
				logger.printThrowable(e);
				logger.print("Couldn't write customization archive.");
				return;
			}
		} else {
			if (customizationZip.exists() && !customizationZip.delete()) {
				logger.print(
						"Couldn't delete customization archive, not a severe error but could be the source of a problem.");
			}
		}

		logger.print("Agent configuration file written.");

		File detectionFilesFolder = new File(connectedBackendFolder, "detection");
		if (!detectionFilesFolder.exists() && !detectionFilesFolder.mkdir()) {
			logger.print("Failed to create the detection files folder.");
			return;
		}
		File detectionFilesPool = new File(detectionFilesFolder, "pool");
		if (!detectionFilesPool.exists() && !detectionFilesPool.mkdir()) {
			logger.print("Failed to create the detection files pool folder.");
			return;
		}
		logger.print("Generating detection files...");

		Properties oldIdxProps = new Properties();
		Properties newIdxProps = new Properties();
		File indexFile = new File(detectionFilesFolder, "detidx.dat");
		File builtTempDetFile = new File(ToolkitMain.getCuToolkitTempFolder(), "bdtemp.tmp");
		if (indexFile.exists() && !indexFile.isDirectory()) {
			try (GZIPInputStream is = new GZIPInputStream(new FileInputStream(indexFile))) {
				oldIdxProps.load(is);
			} catch (IOException e) {
				logger.print("Failed to read the older detection index file.");
				return;
			}
		}
		List<File> newDetectionFiles = new ArrayList<File>();
		for (ProductInfo product : project.getProductsList()) {
			String detFileHash = oldIdxProps.getProperty(product.getProductName());
			DetectionFileBuilder dfb = new DetectionFileBuilder(product);
			Properties newDetectionProps = dfb.buildDetectionProperties();
			boolean modificationNotNeeded = false;
			if (detFileHash != null) {
				File targetOldFile = new File(detectionFilesPool, detFileHash + ".det");
				if (targetOldFile.exists()) {
					try (GZIPInputStream input = new GZIPInputStream(new FileInputStream(targetOldFile))) {
						Properties oldDetectProps = new Properties();
						oldDetectProps.load(input);
						if (oldDetectProps.equals(newDetectionProps)) {
							logger.print("Detection file update not needed for " + product.getProductName() + ".");
							modificationNotNeeded = true;
							newDetectionFiles.add(targetOldFile);
						}
					} catch (IOException e) {
						logger.printThrowable(e);
						logger.print("Failed to read the older detection file " + product.getProductName() + ".");
						return;
					}
				}
			}
			if (!modificationNotNeeded) {
				try (GZIPOutputStream output = new HighCompressionGZOutputStream(
						new FileOutputStream(builtTempDetFile))) {
					newDetectionProps.store(output, PROP_FILE_COMMENT);
				} catch (IOException e) {
					logger.printThrowable(e);
					logger.print("Failed to write the new detection file for " + product.getProductName() + ".");
					return;
				}
				HashComputer hashCptr = new HashComputer(builtTempDetFile, new SharedLoggerAdapter(logger));
				String fileHash = hashCptr.computeHash();
				if (fileHash != null) {
					File targetFile = new File(detectionFilesPool, fileHash + ".det");
					try {
						Files.move(builtTempDetFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING);
					} catch (IOException e) {
						logger.print("Failed to write the final hash file " + targetFile.getName() + ".");
						return;
					}
					newDetectionFiles.add(targetFile);
					detFileHash = fileHash;
				} else {
					logger.print("Failed to compute hash of the temp file for " + product.getProductName() + ".");
					return;
				}
			}
			newIdxProps.setProperty(product.getProductName(), detFileHash);

		}

		try (GZIPOutputStream os = new HighCompressionGZOutputStream(new FileOutputStream(indexFile))) {
			newIdxProps.store(os, PROP_FILE_COMMENT);
		} catch (IOException e) {
			logger.print("Failed to write the detection index file.");
			return;
		}
		logger.print("Cleaning up orphaned entries...");
		for (File fCheck : detectionFilesPool.listFiles()) {
			if (fCheck.isFile() && !newDetectionFiles.contains(fCheck)) {
				if (fCheck.delete()) {
					logger.print("Removed orphaned detection file " + fCheck.getName());
				} else {
					logger.print("Failed to remove orphaned detection file " + fCheck.getName());
				}
			}
		}
		if (builtTempDetFile.exists()) {
			if (!builtTempDetFile.delete()) {
				logger.print(
						"Failed to remove a temporary from the temporary folder. Will be removed on next Toolkit startup.");
			}
		}
		logger.print("Detection files have been synchronized.");

		File productsFolder = new File(connectedBackendFolder, "products");
		if (!productsFolder.exists() && !productsFolder.mkdir()) {
			logger.print("Failed to create the products folder.");
			return;
		}

		File poolFolder = new File(connectedBackendFolder, "pool");
		if (!poolFolder.exists() && !poolFolder.mkdir()) {
			logger.print("Failed to create the pool folder.");
			return;
		}

		logger.print("Generating product information files...");

		File productsFile = new File(productsFolder, "products.dat");

		Properties oldProductsList = new Properties();
		Properties newProductsList = new Properties();
		List<File> newProdInfosFiles = new ArrayList<File>();

		List<File> usedPoolFilesList = new ArrayList<File>();

		if (productsFile.exists()) {
			try (GZIPInputStream fis = new GZIPInputStream(new FileInputStream(productsFile))) {
				oldProductsList.load(fis);
			} catch (IOException e) {
				logger.print("Failed to load current products enumeration.");
				return;
			}
		}

		boolean[] failure = { false };
		productSources.forEach((product, prodSource) -> {
			if (failure[0]) {
				return;
			}
			VersionInfo latestVersion = product.getLatestVersion();
			Properties newProductInfosProps = new Properties();
			newProductInfosProps.setProperty("update.productname", product.getProductName());
			newProductInfosProps.setProperty("update.versionname", latestVersion.getVersionName());
			newProductInfosProps.setProperty("update.description", latestVersion.getVersionDescription());
			newProductInfosProps.setProperty("update.releasedate", "" + latestVersion.getReleaseDate());
			Properties oldProductInfosProps = new Properties();
			String productInfosHash = oldProductsList.getProperty(product.getProductName());
			File targetInfosFile = null;
			if (productInfosHash != null) {
				targetInfosFile = new File(productsFolder, productInfosHash + ".prd");
				try (GZIPInputStream fis = new GZIPInputStream(new FileInputStream(targetInfosFile))) {
					oldProductInfosProps.load(fis);
				} catch (IOException e) {
					logger.print(
							"Failed to read the older product information file for " + product.getProductName() + ".");
					failure[0] = true;
					return;
				}
			} else {
				targetInfosFile = new File(ToolkitMain.getCuToolkitTempFolder(),
						"prinfo" + product.getProductName().hashCode() + ".tmp");
			}

			File poolBinary = null;
			File eulaBinary = null;
			if (oldProductInfosProps.containsKey("update.binhash")) {
				poolBinary = new File(poolFolder, oldProductInfosProps.getProperty("update.binhash") + ".bin");
			} else {
				poolBinary = new File(ToolkitMain.getCuToolkitTempFolder(),
						"prbin" + product.getProductName().hashCode() + "tmp");
			}
			if (oldProductInfosProps.containsKey("update.eulahash")) {
				eulaBinary = new File(poolFolder, oldProductInfosProps.getProperty("update.eulahash") + ".bin");
			} else {
				eulaBinary = new File(ToolkitMain.getCuToolkitTempFolder(),
						"eulabin" + product.getProductName().hashCode() + "tmp");
			}

			File versFldr = new File(prodSource, latestVersion.getVersionName());
			if (!versFldr.exists() || !versFldr.isDirectory()) {
				logger.print("Missing version folder for " + product.getProductName());
				failure[0] = true;
				return;
			}

			File eulaFile = BulkLoadDialog.sharedEulaFileFinder(versFldr, product.getLatestVersion(), toolkitWindow,
					failure);
			if (failure[0]) {
				ToolkitMain.getGlobalLogger().print("Missing EULA for " + product.getProductName());
				failure[0] = true;
				return;
			}
			File moduleFile = BulkLoadDialog.sharedModuleFileFinder(versFldr, product.getLatestVersion(), toolkitWindow,
					failure);
			if (failure[0]) {
				ToolkitMain.getGlobalLogger().print("Missing custom module for " + product.getProductName());
				failure[0] = true;
				return;
			}

			Map<String, File> filesToInsert = new HashMap<String, File>();
			if (!BulkLoadDialog.sharedFileMapMaker(versFldr, product.getLatestVersion(), filesToInsert,
					ToolkitMain.getGlobalLogger())) {
				ToolkitMain.getGlobalLogger().print("Failed to build files map for " + product.getProductName());
				failure[0] = true;
				return;
			}

			if (eulaFile != null) {
				boolean needToUpdate = true;
				if (oldProductInfosProps.containsKey("update.eulahash")) {
					String eulaHash = new HashComputer(eulaFile, new SharedLoggerAdapter(logger)).computeHash();
					if (eulaHash == null) {
						ToolkitMain.getGlobalLogger()
								.print("Failed to compute eula hash of " + product.getProductName());
						failure[0] = true;
						return;
					}
					File extractedEula = new File(ToolkitMain.getCuToolkitTempFolder(),
							"eulaext" + product.getProductName().hashCode() + "tmp");
					try (FileOutputStream output = new FileOutputStream(extractedEula);
							GZIPInputStream input = new GZIPInputStream(new FileInputStream(eulaBinary))) {
						byte buffer[] = new byte[4096];
						int read = input.read(buffer, 0, buffer.length);
						while (read != -1) {
							output.write(buffer, 0, read);
							read = input.read(buffer, 0, buffer.length);
						}
						String eulaHashOld = new HashComputer(extractedEula, new SharedLoggerAdapter(logger))
								.computeHash();
						if (eulaHash.equalsIgnoreCase(eulaHashOld)) {
							ToolkitMain.getGlobalLogger()
									.print("No need to update EULA of " + product.getProductName());
							newProductInfosProps.setProperty("update.eulahash",
									oldProductInfosProps.getProperty("update.eulahash"));
							usedPoolFilesList.add(eulaBinary);
							needToUpdate = false;
						}
					} catch (IOException e) {
						ToolkitMain.getGlobalLogger().print("Failed to extract the previous eula file of "
								+ product.getProductName() + ". Will regenerate.");
						ToolkitMain.getGlobalLogger().printThrowable(e);
					}

				}
				if (needToUpdate) {
					try (GZIPOutputStream output = new GZIPOutputStream(new FileOutputStream(eulaBinary));
							FileInputStream input = new FileInputStream(eulaFile)) {
						byte buffer[] = new byte[4096];
						int read = input.read(buffer, 0, buffer.length);
						while (read != -1) {
							output.write(buffer, 0, read);
							read = input.read(buffer, 0, buffer.length);
						}
					} catch (IOException e) {
						ToolkitMain.getGlobalLogger()
								.print("Failed to copy the eula file of " + product.getProductName());
						ToolkitMain.getGlobalLogger().printThrowable(e);
						failure[0] = true;
						return;
					}
					HashComputer newCptr = new HashComputer(eulaBinary, new SharedLoggerAdapter(logger));
					String newHash = newCptr.computeHash();
					if (newHash == null) {
						ToolkitMain.getGlobalLogger()
								.print("Failed to compute new eula hash of " + product.getProductName());
						failure[0] = true;
						return;
					}
					File finalBinFile = new File(poolFolder, newHash + ".bin");
					try {
						Files.move(eulaBinary.toPath(), finalBinFile.toPath(), StandardCopyOption.REPLACE_EXISTING);
					} catch (IOException e) {
						ToolkitMain.getGlobalLogger()
								.print("Couldn't move finished eula bin file of product " + product.getProductName());
						failure[0] = true;
						return;
					}
					newProductInfosProps.setProperty("update.eulahash", newHash);
					usedPoolFilesList.add(finalBinFile);

				}

			}

			PackageGenerationReport genReport = new PackageGenerationReport();
			StandalonePackageBuilder pkgBuilder = new StandalonePackageBuilder(toolkitWindow, product, latestVersion,
					filesToInsert, eulaFile, moduleFile, null, null, genReport, poolBinary);
			pkgBuilder.runTask(); // This task must be synchronized
			if (genReport.hasPackageCreationFailed()) {
				ToolkitMain.getGlobalLogger()
						.print("Package creation marked as failed for " + product.getProductName());
				failure[0] = true;
				return;
			}

			if (genReport.hasPackageChanged()) {
				HashComputer hCptr = new HashComputer(poolBinary, new SharedLoggerAdapter(getLogger()));
				String hash = hCptr.computeHash();
				if (hash == null) {
					ToolkitMain.getGlobalLogger()
							.print("Couldn't compute hash of new package for " + product.getProductName());
					failure[0] = true;
					return;
				}
				File finalBinFile = new File(poolFolder, hash + ".bin");
				try {
					Files.move(poolBinary.toPath(), finalBinFile.toPath(), StandardCopyOption.REPLACE_EXISTING);
				} catch (IOException e) {
					ToolkitMain.getGlobalLogger()
							.print("Couldn't move finished product bin file " + product.getProductName());
					failure[0] = true;
					return;
				}
				newProductInfosProps.setProperty("update.binhash", hash);
				usedPoolFilesList.add(finalBinFile);
			} else {
				usedPoolFilesList.add(poolBinary);
				newProductInfosProps.setProperty("update.binhash", oldProductInfosProps.getProperty("update.binhash"));
			}

			if (!newProductInfosProps.equals(oldProductInfosProps)) {
				try (HighCompressionGZOutputStream fos = new HighCompressionGZOutputStream(
						new FileOutputStream(targetInfosFile))) {
					newProductInfosProps.store(fos, PROP_FILE_COMMENT);
				} catch (IOException e) {
					logger.print(
							"Failed to write the new product information file for " + product.getProductName() + ".");
					failure[0] = true;
					return;
				}
				HashComputer hashCptr = new HashComputer(targetInfosFile, new SharedLoggerAdapter(getLogger()));
				productInfosHash = hashCptr.computeHash();
				if (productInfosHash == null) {
					logger.print("Failed to compute has for the new product information file of "
							+ product.getProductName() + ".");
					failure[0] = true;
					return;
				}
				try {
					File finalFile = new File(productsFolder, productInfosHash + ".prd");
					Files.move(targetInfosFile.toPath(), finalFile.toPath(), StandardCopyOption.REPLACE_EXISTING);
					newProductsList.put(product.getProductName(), productInfosHash);
					newProdInfosFiles.add(finalFile);
				} catch (IOException e) {
					logger.print(
							"Failed to copy the new product information file for " + product.getProductName() + ".");
					failure[0] = true;
					return;
				}
			} else {
				newProdInfosFiles.add(targetInfosFile);
				newProductsList.put(product.getProductName(), productInfosHash);
			}
			logger.print("Processed tasks for " + product.getProductName() + " version "
					+ latestVersion.getVersionName() + ".");
		});
		if (failure[0]) {
			return;
		}

		if (!newProductsList.equals(oldProductsList)) {
			try (HighCompressionGZOutputStream fos = new HighCompressionGZOutputStream(
					new FileOutputStream(productsFile))) {
				newProductsList.store(fos, PROP_FILE_COMMENT);
			} catch (IOException e) {
				logger.print("Failed to update the products enumeration.");
				return;
			}
		}

		logger.print("Cleaning up orphaned entries...");
		for (File prodFile : productsFolder.listFiles()) {
			if (!prodFile.equals(productsFile) && prodFile.isFile()) {
				if (!newProdInfosFiles.contains(prodFile)) {
					if (prodFile.delete()) {
						logger.print("Removed product information file " + prodFile.getName());
					} else {
						logger.print("Failed to remove orphaned product information file " + prodFile.getName());
					}
				}
			}
		}
		for (File prodFile : poolFolder.listFiles()) {
			if (!usedPoolFilesList.contains(prodFile) && prodFile.isFile()) {
				if (prodFile.delete()) {
					logger.print("Removed product binary update file " + prodFile.getName());
				} else {
					logger.print("Failed to remove orphaned product binary update file " + prodFile.getName());
				}
			}
		}
		logger.print("Synchronizing catalog...");
		File catalogFolder = new File(connectedBackendFolder, "catalog");
		if (!catalogFolder.exists() && !catalogFolder.mkdir()) {
			logger.print("Failed to create the catalog folder.");
			return;
		}

		File poolFolderCatalog = new File(catalogFolder, "pool");
		if (!poolFolderCatalog.exists() && !poolFolderCatalog.mkdir()) {
			logger.print("Failed to create the catalog pool folder.");
			return;
		}

		CatalogHeaderWriter catWrt = new CatalogHeaderWriter(catalogFolder);
		File firstCatalogFile = new File(catalogFolder, catWrt.getCurrentHeaderFile());

		if (!toolkitWindow.getProject().getMainInfosRef().getWebsiteInfos().allowsCatalogUsage()) {
			cleanupFolderCatalogProc(catalogFolder, poolFolderCatalog);
			if (!catWrt.openNewCatalog()) {
				logger.print("Failed to create the catalog initial header file.");
				return;
			}
			catWrt.closeCatalog();
			return;
		}

		if (!firstCatalogFile.exists() && !regenerateCatalog) {

			cleanupFolderCatalogProc(catalogFolder, poolFolderCatalog);

			if (!catWrt.openNewCatalog()) {
				logger.print("Failed to create the catalog initial header file.");
				return;
			}
			catWrt.closeCatalog();
		}
		if (!regenerateCatalog) {
			return;
		}

		logger.print("Regenerating catalog...");

		cleanupFolderCatalogProc(catalogFolder, poolFolderCatalog);

		boolean[] failure2 = { false };
		productSources.forEach((product, prodSource) -> {
			if (failure2[0]) {
				return;
			}
			VersionInfo firstVersion = null;
			for (VersionInfo versInfo : product.getVersionsReference()) {
				if (firstVersion == null || firstVersion.getIterationNumber() > versInfo.getIterationNumber()) {
					firstVersion = versInfo;
				}
			}
			for (VersionInfo versInfo : product.getVersionsReference()) {
				if (versInfo == firstVersion) {
					continue;
				}
				File versFldr = new File(prodSource, versInfo.getVersionName());
				if (!versFldr.exists() || !versFldr.isDirectory()) {
					logger.print("Missing version folder for " + product.getProductName() + " with version "
							+ versInfo.getVersionName());
					failure2[0] = true;
					return;
				}

				File eulaFile = BulkLoadDialog.sharedEulaFileFinder(versFldr, versInfo, toolkitWindow, failure2);
				if (failure2[0]) {
					ToolkitMain.getGlobalLogger().print("Missing EULA for " + product.getProductName()
							+ " with version " + versInfo.getVersionName());
					failure2[0] = true;
					return;
				}
				File moduleFile = BulkLoadDialog.sharedModuleFileFinder(versFldr, versInfo, toolkitWindow, failure2);
				if (failure2[0]) {
					ToolkitMain.getGlobalLogger().print("Missing custom module for " + product.getProductName()
							+ " with version " + versInfo.getVersionName());
					failure2[0] = true;
					return;
				}

				Map<String, File> filesToInsert = new HashMap<String, File>();
				if (!BulkLoadDialog.sharedFileMapMaker(versFldr, versInfo, filesToInsert,
						ToolkitMain.getGlobalLogger())) {
					ToolkitMain.getGlobalLogger().print("Failed to build files map for " + product.getProductName()
							+ " with version " + versInfo.getVersionName());
					failure2[0] = true;
					return;
				}

				StandalonePackageBuilder pkgBuilder = new StandalonePackageBuilder(toolkitWindow, product, versInfo,
						filesToInsert, eulaFile, moduleFile, binpack, ToolkitMain.getCuToolkitTempFolder(), null, null);
				File targetFile = pkgBuilder.setTargetAndGetFile();

				pkgBuilder.runTask();
				if (!targetFile.exists()) {
					logger.print("Failed to generate package for " + product.getProductName() + " with version "
							+ versInfo.getVersionName());
					failure2[0] = true;
					return;
				}
				HashComputer hashCptr = new HashComputer(targetFile, new SharedLoggerAdapter(getLogger()));
				String hash = hashCptr.computeHash();
				if (hash == null) {
					logger.print("Failed to compute package hash for " + product.getProductName() + " with version "
							+ versInfo.getVersionName());
					failure2[0] = true;
					return;
				}
				File target = new File(poolFolderCatalog, targetFile.getName() + "_" + hash + ".jar");
				try {
					Files.move(targetFile.toPath(), target.toPath(), StandardCopyOption.REPLACE_EXISTING);
				} catch (IOException e) {
					logger.printThrowable(e);
					logger.print("Failed to copy the final package for " + product.getProductName() + " with version "
							+ versInfo.getVersionName());
					failure2[0] = true;
					return;
				}
				catWrt.addCatalogEntry(versInfo, target.getName());
			}
		});
		catWrt.closeCatalog();
	}

}
